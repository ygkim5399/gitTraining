#ifndef DAY2

// 3_함수객체4 -  137 page 제일 윗부분내용
       int Add1(int a, int b) { return a + b; }
inline int Add2(int a, int b) { return a + b; }

int main()
{
	int n1 = Add1(1, 2); // 호출
						// 인자2개를 약속된 장소에 넣고
						// Add1 함수로 이동 (call Add1)

	int n2 = Add2(1, 2);	// 치환
							// 이부분을 Add2의 기계어 코드로 교체
							// mov eax, 2
							// add eax, 1
							// n2, eax
							// 장점 : 빠릅니다.	
							// 단점 : 커다란 함수를 여러번 치환하게 되면 
							//		코드 메모리 증가
							//		하지만 Add2 정도는 무시해도 됩니다. (오히려 감소)


	// 함수의 주소를 포인터 변수에 담아서 사용
	int(*f)(int, int) = &Add2;
	// == 
	// if (사용자 입력값 == 1) f == &Add1;

	// f가 어느 함수를 가리키는지는 "컴파일 시간"에는 알 수 없다.
	// 그래서 아래코드는 "치환"될 수 없습니다. 

	f(1, 2); // 호출될까요? 치환될까요? 
}

// 1. 인라인 치환이라는 문법은 "컴파일 시간" 동작  
// 2. 인라인 함수라도 "함수 포인터"에 담아서 사용하면 
//	인라인 치환될 수 없습니다. "호출"입니다. 

#endif